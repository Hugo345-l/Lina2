# Roadmap Detalhado - Projeto Lina v2.0
*Assistente Pessoal Multi-Agente com Arquitetura de Grafo ObservÃ¡vel*

## ğŸ“‹ VisÃ£o Geral da RefatoraÃ§Ã£o

**Status**: RefatoraÃ§Ã£o Profunda em Andamento  
**Foco**: Backend First, Grafo Robusto, Observabilidade Total  
**UI Inicial**: LangGraph Studio (nativo)  
**Tecnologias Core**: LangGraph + LangChain + OpenRouter + SQLite

---

## âš™ï¸ **FASE SETUP: ConfiguraÃ§Ã£o do Ambiente LangGraph Studio** (1 dia)

### **Objetivo**
Configurar e validar o ambiente de desenvolvimento com LangGraph CLI e Studio antes de iniciar a implementaÃ§Ã£o.

### **Tarefa SETUP.1: InstalaÃ§Ã£o e ConfiguraÃ§Ã£o Base**

#### **InstalaÃ§Ã£o do LangGraph CLI**
- [x] Instalar LangGraph CLI com suporte in-memory:
  ```bash
  pip install "langgraph-cli[inmem]>=0.1.55"
  ```
- [x] Verificar instalaÃ§Ã£o:
  ```bash
  langgraph --help
  ```
- [x] Configurar conta LangSmith (necessÃ¡ria para LangGraph Studio):
  - [x] Criar conta em https://smith.langchain.com
  - [x] Gerar API key no LangSmith
  - [x] Configurar variÃ¡vel de ambiente `LANGSMITH_API_KEY`

#### **ConfiguraÃ§Ã£o do Projeto Teste**
- [x] Criar estrutura mÃ­nima de projeto:
  ```
  lina-setup-test/
  â”œâ”€â”€ simple_agent.py
  â”œâ”€â”€ langgraph.json
  â”œâ”€â”€ requirements.txt
  â””â”€â”€ .env
  ```
- [x] Implementar grafo mÃ­nimo funcional em `simple_agent.py`:
  - [x] Estado simples com mensagens
  - [x] NÃ³ Ãºnico que responde "Hello from LangGraph!"
  - [x] CompilaÃ§Ã£o do grafo
- [x] Criar `langgraph.json` bÃ¡sico:
  ```json
  {
    "dependencies": ["."],
    "graphs": {
      "test_agent": "./simple_agent.py:graph"
    },
    "env": ".env"
  }
  ```
- [x] Configurar `.env` com:
  ```
  LANGSMITH_API_KEY=sua_api_key_aqui
  ```

### **Tarefa SETUP.2: ValidaÃ§Ã£o do LangGraph Studio**

#### **Teste do Servidor Local**
- [x] Executar servidor de desenvolvimento com `langgraph dev`.
- [x] Executar servidor de desenvolvimento com `langgraph up` (usando Docker).
- [x] Verificar se ambos os servidores iniciam corretamente.
- [x] Confirmar que o grafo Ã© carregado sem erros em ambas as abordagens.

#### **Teste do LangGraph Studio Web**
- [x] Acessar LangGraph Studio e conectar aos servidores locais.
- [x] Fazer login com conta LangSmith.
- [x] Verificar se o grafo aparece na interface.
- [x] Testar execuÃ§Ã£o do grafo.

### **Tarefa SETUP.3: ExploraÃ§Ã£o das Funcionalidades**

#### **Teste de Funcionalidades Core**
- [x] **VisualizaÃ§Ã£o**: Confirmado que o grafo aparece visualmente.
- [x] **ExecuÃ§Ã£o**: Confirmado, com inputs de teste e verificaÃ§Ã£o de outputs.
- [x] **Debug**: Funcionalidades de interrupÃ§Ã£o e passo-a-passo validadas.
- [x] **Estado**: InspeÃ§Ã£o de estado entre nÃ³s validada.
- [x] **Threading**: CriaÃ§Ã£o e alternÃ¢ncia entre threads validada.
- [x] **ConfiguraÃ§Ã£o**: EdiÃ§Ã£o de configuraÃ§Ãµes validada.

### **Tarefa SETUP.4: DocumentaÃ§Ã£o e PreparaÃ§Ã£o**

#### **DocumentaÃ§Ã£o dos Achados**
- [x] Criar `SETUP_NOTES.md` documentando:
  - [x] Processo de instalaÃ§Ã£o e configuraÃ§Ã£o
  - [x] Estrutura mÃ­nima necessÃ¡ria do projeto
  - [x] Funcionalidades disponÃ­veis no Studio
  - [x] LimitaÃ§Ãµes identificadas
  - [x] DiferenÃ§as entre `langgraph dev` vs `langgraph up`
  - [x] Best practices para desenvolvimento

### **CritÃ©rios de Sucesso**
- [x] LangGraph CLI instalado e funcionando.
- [x] Servidor local (`dev` e `up`) iniciando sem erros.
- [x] LangGraph Studio acessÃ­vel e funcional.
- [x] Grafo de teste executando corretamente.
- [x] Todas as funcionalidades core validadivas.
- [x] DocumentaÃ§Ã£o completa do setup.
- [x] Ambiente pronto para desenvolvimento do projeto principal.


---

## ğŸ¯ **FASE 0: PreparaÃ§Ã£o e Aprendizado** (2-3 dias)

### **Objetivo**
Entender profundamente LangGraph e validar conceitos antes de implementar.

### **Tarefa 0.1: Estudo Dirigido do LangGraph**
- [x] Estudar exemplos oficiais:
  - [x] [Multi-agent supervisor pattern](https://github.com/langchain-ai/langgraph/tree/main/examples/multi_agent)
  - [x] [ReAct agent implementation](https://github.com/langchain-ai/langgraph/tree/main/examples/react)
  - [x] [Human-in-the-loop patterns](https://github.com/langchain-ai/langgraph/tree/main/examples/human_in_the_loop)
- [x] Entender sistema de checkpoints e recuperaÃ§Ã£o de estado
- [x] Explorar capacidades do LangGraph Studio
- [x] Documentar insights e padrÃµes Ãºteis

### **Tarefa 0.2: Prototipagem Conceitual**
- [ ] Criar `experiments/grafo_conceitual.py` com:
  - [ ] Grafo mÃ­nimo com 3 nÃ³s (Front, Memory, Tools)
  - [ ] Estado compartilhado simples
  - [ ] Roteamento bÃ¡sico entre nÃ³s
  - [ ] Logging detalhado de execuÃ§Ã£o
- [ ] Validar no LangGraph Studio:
  - [ ] VisualizaÃ§Ã£o do grafo
  - [ ] InspeÃ§Ã£o de estados
  - [ ] Timeline de execuÃ§Ã£o
- [ ] Documentar aprendizados em `experiments/LEARNINGS.md`

---

## ğŸ—ï¸ **FASE 1: FundaÃ§Ã£o do Grafo Multi-Agente** (1 semana)

### **Objetivo**
Construir a estrutura base do grafo com as trÃªs instÃ¢ncias como conjuntos de nÃ³s especializados.

### **Tarefa 1.1: Arquitetura Base do Grafo**

#### **ImplementaÃ§Ã£o do Estado Unificado**
```python
# lina-backend/core/state.py
class LinaState(TypedDict):
    # Estados compartilhados
    messages: List[BaseMessage]
    current_user_intent: Dict
    thread_id: str
    user_id: str
    
    # Estados especÃ­ficos
    front_context: Dict
    memory_context: Dict
    tool_context: Dict
    
    # Observabilidade
    execution_path: List[str]
    decisions: List[Dict]
    node_metrics: Dict[str, Dict]
    total_cost: float
    total_tokens: int
```

#### **Checklist**
- [ ] Criar estrutura de diretÃ³rios:
  ```
  lina-backend/
  â”œâ”€â”€ core/
  â”‚   â”œâ”€â”€ state.py
  â”‚   â”œâ”€â”€ nodes/
  â”‚   â”‚   â”œâ”€â”€ supervisor.py
  â”‚   â”‚   â”œâ”€â”€ front/
  â”‚   â”‚   â”œâ”€â”€ memory/
  â”‚   â”‚   â””â”€â”€ tools/
  â”‚   â””â”€â”€ graph.py
  â”œâ”€â”€ mcps/
  â”œâ”€â”€ utils/
  â””â”€â”€ main.py
  ```
- [ ] Implementar `LinaState` com tipagem completa
- [ ] Criar sistema de logging estruturado
- [ ] Configurar LangSmith tracing

### **Tarefa 1.2: Supervisor e Roteamento**

#### **ImplementaÃ§Ã£o**
- [ ] `supervisor_node`: Analisa intent e roteia
- [ ] Sistema de decisÃ£o com reasoning explÃ­cito
- [ ] MÃºltiplos caminhos possÃ­veis:
  - [ ] Fast path (Front only)
  - [ ] Context path (Front â†’ Memory â†’ Front)
  - [ ] Action path (Front â†’ Tools â†’ Front)
  - [ ] Full path (Front â†’ Memory â†’ Tools â†’ Front)

#### **CritÃ©rios de DecisÃ£o**
```python
def routing_decision(intent: Dict) -> str:
    """
    Retorna prÃ³ximo nÃ³ baseado em:
    - Complexidade da tarefa
    - Necessidade de contexto histÃ³rico
    - Necessidade de aÃ§Ãµes externas
    - PreferÃªncias do usuÃ¡rio
    """
```

### **Tarefa 1.3: NÃ³s da Lina-Front**

#### **NÃ³s a Implementar**
- [ ] `front_interpreter`: ExtraÃ§Ã£o de intent e entities
- [ ] `quick_responder`: Respostas rÃ¡pidas sem LLM
- [ ] `context_enricher`: Adiciona contexto da conversa atual
- [ ] `response_formatter`: Formata resposta final

#### **Ferramentas do Front**
- [ ] Calculadora simples
- [ ] Conversor de unidades
- [ ] Data/hora atual
- [ ] FAQ estÃ¡tico

### **Tarefa 1.4: NÃ³s da Lina-Memory**

#### **NÃ³s a Implementar**
- [ ] `memory_searcher`: Busca vetorial em histÃ³rico
- [ ] `pattern_analyzer`: Identifica padrÃµes de uso
- [ ] `context_distiller`: Resume contexto relevante
- [ ] `memory_writer`: Salva novas memÃ³rias

#### **Setup Inicial**
- [ ] Configurar FAISS para vector store local
- [ ] Implementar sistema de embeddings
- [ ] Criar Ã­ndices bÃ¡sicos

### **Tarefa 1.5: NÃ³s da Lina-Tools**

#### **NÃ³s a Implementar**
- [ ] `tool_selector`: Escolhe ferramenta apropriada
- [ ] `tool_executor`: Executa via MCP
- [ ] `result_validator`: Valida resultados
- [ ] `progress_reporter`: Reporta progresso de tarefas longas

#### **PreparaÃ§Ã£o para MCPs**
- [ ] Interface abstrata para MCPs
- [ ] Sistema de registro de ferramentas
- [ ] Error handling robusto

### **Tarefa 1.6: IntegraÃ§Ã£o e Testes**

#### **ValidaÃ§Ãµes**
- [ ] Fluxo Fast Path funcionando
- [ ] Handoffs entre nÃ³s sem perda de contexto
- [ ] Estado consistente atravÃ©s do fluxo
- [ ] MÃ©tricas por nÃ³ sendo coletadas
- [ ] VisualizaÃ§Ã£o correta no LangGraph Studio

---

## ğŸ”§ **FASE 2: MCPs Elementares** (1 semana)

### **Objetivo**
Implementar ferramentas bÃ¡sicas que demonstram capacidades de cada instÃ¢ncia.

### **Tarefa 2.1: MCP Sistema de Arquivos**

#### **Funcionalidades**
- [ ] Listar arquivos em diretÃ³rio
- [ ] Ler conteÃºdo de arquivo
- [ ] Criar arquivo com conteÃºdo
- [ ] Mover/renomear arquivos
- [ ] Buscar arquivos por padrÃ£o

#### **SeguranÃ§a**
- [ ] Sandbox em diretÃ³rio especÃ­fico
- [ ] ValidaÃ§Ã£o de paths
- [ ] Limites de tamanho
- [ ] Tipos de arquivo permitidos

### **Tarefa 2.2: MCP Pesquisa Web**

#### **Funcionalidades**
- [ ] Buscar via DuckDuckGo API
- [ ] Extrair conteÃºdo de pÃ¡ginas
- [ ] Resumir resultados
- [ ] Cache de resultados

#### **ImplementaÃ§Ã£o**
- [ ] Rate limiting
- [ ] User agent apropriado
- [ ] Parsing robusto de HTML

### **Tarefa 2.3: MCP Tempo e CalendÃ¡rio**

#### **Funcionalidades Front (leves)**
- [ ] Data/hora atual
- [ ] ConversÃ£o de timezones
- [ ] CÃ¡lculos de data simples

#### **Funcionalidades Tools (complexas)**
- [ ] Criar eventos (mock inicial)
- [ ] Listar eventos
- [ ] Verificar disponibilidade

### **Tarefa 2.4: MCP MemÃ³ria Local**

#### **Funcionalidades**
- [ ] Salvar conversa com embeddings
- [ ] Busca por similaridade
- [ ] EstatÃ­sticas de uso
- [ ] Exportar/importar memÃ³rias

### **Tarefa 2.5: IntegraÃ§Ã£o com Grafo**

#### **ImplementaÃ§Ã£o**
- [ ] Registrar MCPs nos nÃ³s apropriados
- [ ] Testar fluxos completos com ferramentas
- [ ] Ajustar roteamento baseado em ferramentas disponÃ­veis
- [ ] Validar no LangGraph Studio

---

## ğŸ§  **FASE 3: InteligÃªncia e Observabilidade** (2 semanas)

### **Objetivo**
Adicionar capacidades avanÃ§adas de memÃ³ria e melhorar observabilidade.

### **Tarefa 3.1: Sistema de MemÃ³ria AvanÃ§ado**

#### **ImplementaÃ§Ãµes**
- [ ] MemÃ³ria episÃ³dica (conversas completas)
- [ ] MemÃ³ria semÃ¢ntica (conceitos e relaÃ§Ãµes)
- [ ] MemÃ³ria procedural (como fazer tarefas)
- [ ] Sistema de esquecimento (relevÃ¢ncia temporal)

### **Tarefa 3.2: AnÃ¡lise de PadrÃµes**

#### **Funcionalidades**
- [ ] Identificar horÃ¡rios preferenciais
- [ ] Detectar tarefas recorrentes
- [ ] Aprender preferÃªncias implÃ­citas
- [ ] Gerar insights automÃ¡ticos

### **Tarefa 3.3: Observabilidade Aprimorada**

#### **ImplementaÃ§Ãµes**
- [ ] Custom callbacks para LangSmith
- [ ] MÃ©tricas detalhadas por nÃ³:
  - [ ] LatÃªncia
  - [ ] Tokens usados
  - [ ] DecisÃµes tomadas
  - [ ] ConfianÃ§a nas decisÃµes
- [ ] Sistema de replay de execuÃ§Ãµes
- [ ] ExportaÃ§Ã£o de traces para anÃ¡lise

### **Tarefa 3.4: OtimizaÃ§Ã£o de Performance**

#### **Melhorias**
- [ ] Cache inteligente de respostas
- [ ] PrÃ©-computaÃ§Ã£o de embeddings
- [ ] Roteamento otimizado por custo
- [ ] ExecuÃ§Ã£o paralela onde possÃ­vel

---

## ğŸ¨ **FASE 4: Interface Customizada** (quando grafo maduro)

### **Objetivo**
Criar interface especÃ­fica para necessidades alÃ©m do LangGraph Studio.

### **Tarefa 4.1: API de Observabilidade**

#### **Endpoints**
- [ ] `GET /execution/{id}/timeline`
- [ ] `GET /execution/{id}/state/{node}`
- [ ] `GET /execution/{id}/decisions`
- [ ] `GET /threads/{user_id}`
- [ ] `WebSocket /execution/live`

### **Tarefa 4.2: Frontend de Debug AvanÃ§ado**

#### **Componentes**
- [ ] Timeline vertical interativa
- [ ] VisualizaÃ§Ã£o de grafo (D3.js/Mermaid)
- [ ] Inspetor de estado por nÃ³
- [ ] Replay de execuÃ§Ãµes
- [ ] ComparaÃ§Ã£o entre execuÃ§Ãµes

### **Tarefa 4.3: Analytics Dashboard**

#### **MÃ©tricas**
- [ ] Uso por tipo de fluxo
- [ ] Custo por usuÃ¡rio/perÃ­odo
- [ ] Taxa de sucesso por tipo de tarefa
- [ ] PadrÃµes de uso temporal

---

## ğŸ“Š **MÃ©tricas de ValidaÃ§Ã£o por Fase**

### **Fase 1 - FundaÃ§Ã£o**
- [ ] Grafo com 10+ nÃ³s funcionando
- [ ] 4 tipos de fluxo implementados
- [ ] Estado consistente em todos os fluxos
- [ ] Traces completos no LangSmith

### **Fase 2 - MCPs**
- [ ] 4 MCPs funcionais
- [ ] 20+ operaÃ§Ãµes disponÃ­veis
- [ ] Taxa de sucesso > 95%
- [ ] DocumentaÃ§Ã£o completa de cada MCP

### **Fase 3 - InteligÃªncia**
- [ ] 1000+ memÃ³rias armazenadas em testes
- [ ] Busca semÃ¢ntica < 100ms
- [ ] 5+ tipos de padrÃµes detectados
- [ ] ReduÃ§Ã£o de 30% no custo via otimizaÃ§Ã£o

### **Fase 4 - Interface**
- [ ] Timeline completa de execuÃ§Ãµes
- [ ] VisualizaÃ§Ã£o de grafo funcional
- [ ] Analytics em tempo real
- [ ] Export de dados para anÃ¡lise

---

## ğŸš« **Anti-PadrÃµes a Evitar**

1. **NÃ£o comeÃ§ar pela UI** - Backend primeiro!
2. **NÃ£o criar nÃ³s sem observabilidade** - Cada nÃ³ deve ser rastreÃ¡vel
3. **NÃ£o otimizar prematuramente** - Funcionalidade antes de performance
4. **NÃ£o acoplar nÃ³s desnecessariamente** - Manter modularidade
5. **NÃ£o pular testes no LangGraph Studio** - Validar cada etapa

---

## ğŸ“… **Timeline Estimada**

- **Dia 1**: Fase SETUP completa
- **Semana 1**: Fase 0 + InÃ­cio Fase 1
- **Semana 2**: ConclusÃ£o Fase 1 + InÃ­cio Fase 2
- **Semana 3**: ConclusÃ£o Fase 2
- **Semanas 4-5**: Fase 3 completa
- **Semana 6+**: Fase 4 (se necessÃ¡rio)

---

## âœ… **Definition of Done**

Cada tarefa sÃ³ estÃ¡ completa quando:
1. CÃ³digo implementado e funcionando
2. Testes escritos e passando
3. DocumentaÃ§Ã£o atualizada
4. Validado no LangGraph Studio
5. MÃ©tricas de observabilidade funcionando
6. Code review (mesmo que self-review) feito

---

*Este roadmap Ã© um documento vivo e serÃ¡ atualizado conforme aprendemos mais sobre o sistema.*
